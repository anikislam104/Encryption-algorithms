import time
import sys
import random
import os

# Set higher recursion depth for large number calculations
sys.setrecursionlimit(2000)

def mod_inverse(a, m):
    """
    Calculates the modular multiplicative inverse of 'a' modulo 'm'
    using the Extended Euclidean Algorithm.
    
    (a * x) % m = 1
    Returns x.
    """
    if a == 0:
        raise ValueError("Cannot calculate inverse of 0")
    if m == 1:
        return 0
    
    m0, x0, x1 = m, 0, 1
    
    # Store the original 'a' value
    orig_a = a
    
    while a > 1:
        try:
            q = a // m
        except ZeroDivisionError:
            raise ValueError("Modulus m cannot be zero")
            
        m, a = a % m, m
        x0, x1 = x1 - q * x0, x0

    if x1 < 0:
        x1 += m0
        
    # Check if 'a' and 'm' were coprime
    if (orig_a * x1) % m0 != 1:
         raise ValueError(f"Modular inverse does not exist for {orig_a} and {m0}")

    return x1

class EllipticCurve:
    """
    Represents an elliptic curve y^2 = x^3 + ax + b (mod p).
    
    This class will hold the parameters for the secp256k1 curve.
    """
    def __init__(self, p, a, b, Gx, Gy, n):
        self.p = p   # The prime modulus of the finite field
        self.a = a   # Coefficient 'a'
        self.b = b   # Coefficient 'b'
        self.Gx = Gx # x-coordinate of the generator point G
        self.Gy = Gy # y-coordinate of the generator point G
        self.G = (Gx, Gy) # The generator point G
        self.n = n   # The order of the generator point G (a large prime)
        
        # We also need a representation for the "point at infinity"
        self.infinity = (None, None)

# --- Define the secp256k1 curve parameters ---
# These are the standard, well-vetted parameters used by Bitcoin and others.
# p = 2^256 - 2^32 - 977
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
# a = 0
a = 0x0000000000000000000000000000000000000000000000000000000000000000
# b = 7
b = 0x0000000000000000000000000000000000000000000000000000000000000007
# Gx (x-coord of generator)
Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
# Gy (y-coord of generator)
Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
# n = order of the group generated by G (a large prime)
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

# Create an instance of our curve
secp256k1 = EllipticCurve(p, a, b, Gx, Gy, n)

# --- Core ECC Point Operations ---

def is_on_curve(point, curve):
    """Checks if a point (x, y) is on the given curve."""
    if point == curve.infinity:
        return True # The point at infinity is always on the curve
    x, y = point
    
    # Check y^2 = x^3 + ax + b (mod p)
    lhs = (y * y) % curve.p
    rhs = (x**3 + curve.a * x + curve.b) % curve.p
    return lhs == rhs

def point_add(P, Q, curve):
    """
    Performs point addition P + Q on the elliptic curve.
    """
    # Handle the point at infinity (the identity element)
    if P == curve.infinity:
        return Q
    if Q == curve.infinity:
        return P

    Px, Py = P
    Qx, Qy = Q

    # Handle point doubling (P == Q)
    if Px == Qx and Py == Qy:
        return point_double(P, curve)

    # Handle P = -Q (which results in the point at infinity)
    if Px == Qx and (Py != Qy or Py == 0):
        # Py = -Qy mod p  (or Py = Qy = 0)
        return curve.infinity
        
    # Standard case: P != Q and P != -Q
    try:
        # s = (y2 - y1) / (x2 - x1) mod p
        dy = (Qy - Py) % curve.p
        dx = (Qx - Px) % curve.p
        s = (dy * mod_inverse(dx, curve.p)) % curve.p
    except ValueError:
        # This can happen if dx = 0, which is covered by Px == Qx case
        # But good to have a catch
        return curve.infinity

    # x3 = s^2 - x1 - x2 mod p
    Rx = (s**2 - Px - Qx) % curve.p
    # y3 = s(x1 - x3) - y1 mod p
    Ry = (s * (Px - Rx) - Py) % curve.p

    return (Rx, Ry)

def point_double(P, curve):
    """
    Performs point doubling 2 * P on the elliptic curve.
    """
    if P == curve.infinity:
        return curve.infinity
        
    Px, Py = P
    
    # If y-coordinate is 0, the tangent is vertical,
    # and 2P is the point at infinity.
    if Py == 0:
        return curve.infinity

    try:
        # s = (3x1^2 + a) / (2y1) mod p
        numerator = (3 * Px**2 + curve.a) % curve.p
        denominator = (2 * Py) % curve.p
        s = (numerator * mod_inverse(denominator, curve.p)) % curve.p
    except ValueError:
        # This should not happen if Py != 0 and p > 2
        return curve.infinity

    # x3 = s^2 - 2x1 mod p
    Rx = (s**2 - 2 * Px) % curve.p
    # y3 = s(x1 - x3) - y1 mod p
    Ry = (s * (Px - Rx) - Py) % curve.p

    return (Rx, Ry)

def scalar_multiply(k, P, curve):
    """
    Performs scalar multiplication k * P using the double-and-add algorithm.
    'k' is an integer, 'P' is a point.
    """
    if k == 0:
        return curve.infinity
    if P == curve.infinity:
        return curve.infinity
        
    # Ensure k is positive
    if k < 0:
        # k*P = -k * (-P)
        k = -k
        P = (P[0], -P[1] % curve.p)

    # Reduce k modulo n (the order of the generator)
    k = k % curve.n
    if k == 0:
        return curve.infinity

    current = P
    result = curve.infinity
    
    # Use binary expansion of k
    i = 0
    while k > 0:
        if k % 2 == 1:
            result = point_add(result, current, curve)
        
        # Double the point for the next bit
        current = point_double(current, curve)
        k = k // 2
        i += 1

    return result

# --- ECC ElGamal Key Generation, Encryption, Decryption ---

def generate_keys(curve):
    """
    Generates an ECC key pair (private and public).
    """
    # Private key 'd' is a random integer: 1 < d < n
    d = random.randint(1, curve.n - 1)
    
    # Public key 'H' is a point: H = d * G
    H = scalar_multiply(d, curve.G, curve)
    
    # Public key is (curve, H)
    # Private key is 'd'
    public_key = H
    private_key = d
    
    return (public_key, private_key)

def encrypt(public_key, plaintext, curve):
    """
    Encrypts a plaintext string using ECC ElGamal hybrid scheme.
    
    For each character 'm':
    1. Choose a random ephemeral key 'k' (1 < k < n)
    2. Calculate C1 = k * G
    3. Calculate S = k * H  (the shared secret point, H is public key)
    4. Use S.x as a one-time-pad/mask: C2 = m + S.x (mod p)
    
    Ciphertext is a list of (C1, C2) pairs.
    """
    H = public_key
    ciphertext = []
    
    try:
        for char in plaintext:
            # Convert character to its integer representation
            m = ord(char)
            
            # 1. Choose a random ephemeral key 'k'
            k = random.randint(1, curve.n - 1)
            
            # 2. Calculate C1 = k * G
            C1 = scalar_multiply(k, curve.G, curve)
            
            # 3. Calculate S = k * H
            S = scalar_multiply(k, H, curve)
            Sx, Sy = S
            
            if Sx is None: # Should not happen if k != 0
                continue
            
            # 4. Calculate C2 = (m + S.x) % p
            # We use addition as a simple mask.
            # A real system would use KDF on S.x to feed a symmetric cipher.
            C2 = (m + Sx) % curve.p
            
            ciphertext.append((C1, C2))
            
        return ciphertext
        
    except Exception as e:
        print(f"Encryption error: {e}")
        return None

def decrypt(private_key, ciphertext, curve):
    """
    Decrypts a list of ciphertext (C1, C2) pairs.
    
    For each (C1, C2) pair:
    1. Calculate S = d * C1  (d is private key)
    2. Recover m = (C2 - S.x) % p
    """
    d = private_key
    plaintext_list = []
    
    try:
        for C1, C2 in ciphertext:
            # 1. Calculate S = d * C1
            S = scalar_multiply(d, C1, curve)
            Sx, Sy = S
            
            if Sx is None:
                continue # This C1 was invalid, resulted in infinity

            # 2. Recover m = (C2 - S.x) % p
            # This works because S = d*C1 = d*(k*G) = k*(d*G) = k*H
            m_int = (C2 - Sx) % curve.p
            
            # Convert integer back to character
            plaintext_list.append(chr(m_int))
            
        return "".join(plaintext_list)
        
    except ValueError as e:
        print(f"Decryption error: {e}. Possible key mismatch or data corruption.")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during decryption: {e}")
        return None


def run_ecc_demo(plaintext):
    # --- Helper strings for printing ---
    # Convert big ints to hex strings for cleaner printing
    secp256k1.p_str = f"0x{secp256k1.p:X}"
    secp256k1.Gx_str = f"0x{secp256k1.G[0]:X}"
    secp256k1.Gy_str = f"0x{secp256k1.G[1]:X}"
    curve = secp256k1
    
    # print(f"--- ECC Algorithm Demonstration ---")
    # print(f"Using curve secp256k1")
    # print(f"Prime p = {secp256k1.p_str[:15]}...")
    # print(f"Generator G = ({secp256k1.Gx_str[:15]}..., {secp256k1.Gy_str[:15]}...)")
    
    # --- Key Generation ---
    # print("\n1. Generating Keys...")
    start_key_gen = time.perf_counter()
    try:
        public_key, private_key = generate_keys(curve)
    except Exception as e:
        print(f"Key Generation FAILED: {e}")
        return
    end_key_gen = time.perf_counter()
    key_gen_time = end_key_gen - start_key_gen
    
    Hx, Hy = public_key
    Hx_str = f"0x{Hx:X}"
    Hy_str = f"0x{Hy:X}"
    # print(f"   Public Key (H): ({Hx_str[:15]}..., {Hy_str[:15]}...)")
    # print(f"   Private Key (d): [SECRET]")

    # # --- Encryption ---
    # print(f"\n2. Encrypting Message...")
    # print(f"   Plaintext: '{plaintext}'")
    
    start_encrypt = time.perf_counter()
    encrypted_msg = encrypt(public_key, plaintext, curve)
    end_encrypt = time.perf_counter()
    encrypt_time = end_encrypt - start_encrypt
    
    if encrypted_msg:
        # print(f"\n   Encrypted Text (list of (C1, C2) pairs):")
        # Print a snippet
        c1_point, c2_int = encrypted_msg[0]
        c1x, c1y = c1_point
        c1x_str = f"0x{c1x:X}"
        c2_int_str = f"0x{c2_int:X}"
        # print(f"   First char: (C1=( {c1x_str[:10]}... ), C2=( {c2_int_str[:10]}... ))")
        # if len(encrypted_msg) > 1:
        #         print(f"   ... and {len(encrypted_msg) - 1} more pairs.")
    else:
        # print("Encryption FAILED.")
        return

    # --- Decryption ---
    # print(f"\n3. Decrypting Message...")
    
    start_decrypt = time.perf_counter()
    decrypted_msg = decrypt(private_key, encrypted_msg, curve)
    end_decrypt = time.perf_counter()
    decrypt_time = end_decrypt - start_decrypt

    # if decrypted_msg:
    #     print(f"   Decrypted Plaintext: '{decrypted_msg}'")
    # else:
    #     print("Decryption FAILED.")
    #     return

    # --- Verification and Performance ---
    # print("\n--- Verification ---")
    # if plaintext == decrypted_msg:
    #     print("   SUCCESS: Decrypted text matches original plaintext.")
    # else:
    #     print("   FAILURE: Decrypted text does NOT match original plaintext.")

    # print("\n--- Performance ---")
    # print(f"   Key Generation Time: {(key_gen_time * 1000):.6f} milliseconds")
    # print(f"   Encryption Time:     {(encrypt_time * 1000):.6f} milliseconds")
    # print(f"   Decryption Time:     {(decrypt_time * 1000):.6f} milliseconds")
    
    total_time = key_gen_time + encrypt_time + decrypt_time
    # print(f"   Total Time:          {(total_time * 1000):.6f} milliseconds")
    
    return key_gen_time, encrypt_time, decrypt_time, total_time

# --- Main execution ---
if __name__ == "__main__":

    # Add helper strings to the demo function as well
    # Define the plaintext message here
    plaintext_message = "Hello jdaisjdaiosjdajsio!"
    
    # Call the main demonstration function
    # Note: This will be slow! Scalar multiplication is computationally
    # expensive in pure Python with 256-bit numbers.
    run_ecc_demo(plaintext_message)